(function(){"use strict";try{if(typeof document<"u"){var e=document.createElement("style");e.appendChild(document.createTextNode(".glide{box-sizing:border-box;width:100%;position:relative}.glide *{box-sizing:inherit}.glide__track{overflow:hidden}.glide__slides{-webkit-backface-visibility:hidden;backface-visibility:hidden;transform-style:preserve-3d;touch-action:pan-Y;white-space:nowrap;will-change:transform;flex-wrap:nowrap;width:100%;margin:0;padding:0;list-style:none;display:flex;position:relative;overflow:hidden}.glide__slides--dragging{-webkit-user-select:none;user-select:none}.glide__slide{white-space:normal;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent;flex-shrink:0;width:100%;height:100%}.glide__slide a{-webkit-user-select:none;user-select:none;-webkit-user-drag:none}.glide__arrows,.glide__bullets{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}.glide--rtl{direction:rtl}.glide__arrow{z-index:2;color:#fff;text-transform:uppercase;text-shadow:0 .25em .5em #0000001a;opacity:1;cursor:pointer;background-color:#0000;border:2px solid #ffffff80;border-radius:4px;padding:9px 12px;line-height:1;transition:opacity .15s,border .3s ease-in-out;display:block;position:absolute;top:50%;transform:translateY(-50%);box-shadow:0 .25em .5em #0000001a}.glide__arrow:focus{outline:none}.glide__arrow:hover{border-color:#fff}.glide__arrow--left{left:2em}.glide__arrow--right{right:2em}.glide__arrow--disabled{opacity:.33}.glide__bullets{z-index:2;list-style:none;display:inline-flex;position:absolute;bottom:2em;left:50%;transform:translate(-50%)}.glide__bullet{cursor:pointer;background-color:#ffffff80;border:2px solid #0000;border-radius:50%;width:9px;height:9px;margin:0 .25em;padding:0;line-height:0;transition:all .3s ease-in-out;box-shadow:0 .25em .5em #0000001a}.glide__bullet:focus{outline:none}.glide__bullet:hover,.glide__bullet:focus{background-color:#ffffff80;border:2px solid #fff}.glide__bullet--active{background-color:#fff}.glide--swipeable{cursor:grab;cursor:-moz-grab;cursor:-webkit-grab}.glide--dragging{cursor:grabbing;cursor:-moz-grabbing;cursor:-webkit-grabbing}.glide .glide__track .glide__slides{height:100%}.glide .glide__track .glide__slides .glide__slide{aspect-ratio:4/3;background-color:#ffffff0d;place-content:center;font-size:34px;display:grid}.glide .glide__arrows .glide__arrow{box-shadow:none;width:var(--arrow-width,42px);height:var(--arrow-height,42px);border:0;padding:0}.glide .glide__arrows .glide__arrow.glide__arrow--left{left:1.25em}.glide .glide__arrows .glide__arrow.glide__arrow--right{right:1.25em}.glide .glide__bullets{bottom:1.25em}")),document.head.appendChild(e)}}catch(i){console.error("vite-plugin-css-injected-by-js",i)}})();
/*!
 * Glide.js v3.6.2
 * (c) 2013-2024 Jędrzej Chałubek (https://github.com/jedrzejchalubek/)
 * Released under the MIT License.
 */
function F(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(e, s).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function q(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? F(Object(r), !0).forEach(function(n) {
      rt(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : F(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function H(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? H = function(t) {
    return typeof t;
  } : H = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, H(e);
}
function B(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function nt(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function L(e, t, r) {
  return t && nt(e.prototype, t), e;
}
function rt(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
function it(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), t && j(e, t);
}
function T(e) {
  return T = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, T(e);
}
function j(e, t) {
  return j = Object.setPrototypeOf || function(n, s) {
    return n.__proto__ = s, n;
  }, j(e, t);
}
function st() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function at(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function ot(e, t) {
  if (t && (typeof t == "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return at(e);
}
function ut(e) {
  var t = st();
  return function() {
    var n = T(e), s;
    if (t) {
      var i = T(this).constructor;
      s = Reflect.construct(n, arguments, i);
    } else
      s = n.apply(this, arguments);
    return ot(this, s);
  };
}
function ct(e, t) {
  for (; !Object.prototype.hasOwnProperty.call(e, t) && (e = T(e), e !== null); )
    ;
  return e;
}
function x() {
  return typeof Reflect < "u" && Reflect.get ? x = Reflect.get : x = function(t, r, n) {
    var s = ct(t, r);
    if (s) {
      var i = Object.getOwnPropertyDescriptor(s, r);
      return i.get ? i.get.call(arguments.length < 3 ? t : n) : i.value;
    }
  }, x.apply(this, arguments);
}
var ft = {
  /**
   * Type of the movement.
   *
   * Available types:
   * `slider` - Rewinds slider to the start/end when it reaches the first or last slide.
   * `carousel` - Changes slides without starting over when it reaches the first or last slide.
   *
   * @type {String}
   */
  type: "slider",
  /**
   * Start at specific slide number defined with zero-based index.
   *
   * @type {Number}
   */
  startAt: 0,
  /**
   * A number of slides visible on the single viewport.
   *
   * @type {Number}
   */
  perView: 1,
  /**
   * Focus currently active slide at a specified position in the track.
   *
   * Available inputs:
   * `center` - Current slide will be always focused at the center of a track.
   * `0,1,2,3...` - Current slide will be focused on the specified zero-based index.
   *
   * @type {String|Number}
   */
  focusAt: 0,
  /**
   * A size of the gap added between slides.
   *
   * @type {Number}
   */
  gap: 10,
  /**
   * Change slides after a specified interval. Use `false` for turning off autoplay.
   *
   * @type {Number|Boolean}
   */
  autoplay: !1,
  /**
   * Stop autoplay on mouseover event.
   *
   * @type {Boolean}
   */
  hoverpause: !0,
  /**
   * Allow for changing slides with left and right keyboard arrows.
   *
   * @type {Boolean}
   */
  keyboard: !0,
  /**
   * Stop running `perView` number of slides from the end. Use this
   * option if you don't want to have an empty space after
   * a slider. Works only with `slider` type and a
   * non-centered `focusAt` setting.
   *
   * @type {Boolean}
   */
  bound: !1,
  /**
   * Minimal swipe distance needed to change the slide. Use `false` for turning off a swiping.
   *
   * @type {Number|Boolean}
   */
  swipeThreshold: 80,
  /**
   * Minimal mouse drag distance needed to change the slide. Use `false` for turning off a dragging.
   *
   * @type {Number|Boolean}
   */
  dragThreshold: 120,
  /**
   * A number of slides moved on single swipe.
   *
   * Available types:
   * `` - Moves slider by one slide per swipe
   * `|` - Moves slider between views per swipe (number of slides defined in `perView` options)
   *
   * @type {String}
   */
  perSwipe: "",
  /**
   * Moving distance ratio of the slides on a swiping and dragging.
   *
   * @type {Number}
   */
  touchRatio: 0.5,
  /**
   * Angle required to activate slides moving on swiping or dragging.
   *
   * @type {Number}
   */
  touchAngle: 45,
  /**
   * Duration of the animation in milliseconds.
   *
   * @type {Number}
   */
  animationDuration: 400,
  /**
   * Allows looping the `slider` type. Slider will rewind to the first/last slide when it's at the start/end.
   *
   * @type {Boolean}
   */
  rewind: !0,
  /**
   * Duration of the rewinding animation of the `slider` type in milliseconds.
   *
   * @type {Number}
   */
  rewindDuration: 800,
  /**
   * Easing function for the animation.
   *
   * @type {String}
   */
  animationTimingFunc: "cubic-bezier(.165, .840, .440, 1)",
  /**
   * Wait for the animation to finish until the next user input can be processed
   *
   * @type {boolean}
   */
  waitForTransition: !0,
  /**
   * Throttle costly events at most once per every wait milliseconds.
   *
   * @type {Number}
   */
  throttle: 10,
  /**
   * Moving direction mode.
   *
   * Available inputs:
   * - 'ltr' - left to right movement,
   * - 'rtl' - right to left movement.
   *
   * @type {String}
   */
  direction: "ltr",
  /**
   * The distance value of the next and previous viewports which
   * have to peek in the current view. Accepts number and
   * pixels as a string. Left and right peeking can be
   * set up separately with a directions object.
   *
   * For example:
   * `100` - Peek 100px on the both sides.
   * { before: 100, after: 50 }` - Peek 100px on the left side and 50px on the right side.
   *
   * @type {Number|String|Object}
   */
  peek: 0,
  /**
   * Defines how many clones of current viewport will be generated.
   *
   * @type {Number}
   */
  cloningRatio: 1,
  /**
   * Collection of options applied at specified media breakpoints.
   * For example: display two slides per view under 800px.
   * `{
   *   '800px': {
   *     perView: 2
   *   }
   * }`
   */
  breakpoints: {},
  /**
   * Collection of internally used HTML classes.
   *
   * @todo Refactor `slider` and `carousel` properties to single `type: { slider: '', carousel: '' }` object
   * @type {Object}
   */
  classes: {
    swipeable: "glide--swipeable",
    dragging: "glide--dragging",
    direction: {
      ltr: "glide--ltr",
      rtl: "glide--rtl"
    },
    type: {
      slider: "glide--slider",
      carousel: "glide--carousel"
    },
    slide: {
      clone: "glide__slide--clone",
      active: "glide__slide--active"
    },
    arrow: {
      disabled: "glide__arrow--disabled"
    },
    nav: {
      active: "glide__bullet--active"
    }
  }
};
function b(e) {
  console.error("[Glide warn]: ".concat(e));
}
function p(e) {
  return parseInt(e);
}
function lt(e) {
  return parseFloat(e);
}
function D(e) {
  return typeof e == "string";
}
function k(e) {
  var t = H(e);
  return t === "function" || t === "object" && !!e;
}
function P(e) {
  return typeof e == "function";
}
function Z(e) {
  return typeof e > "u";
}
function z(e) {
  return e.constructor === Array;
}
function dt(e, t, r) {
  var n = {};
  for (var s in t)
    P(t[s]) ? n[s] = t[s](e, n, r) : b("Extension must be a function");
  for (var i in n)
    P(n[i].mount) && n[i].mount();
  return n;
}
function h(e, t, r) {
  Object.defineProperty(e, t, r);
}
function ht(e) {
  return Object.keys(e).sort().reduce(function(t, r) {
    return t[r] = e[r], t[r], t;
  }, {});
}
function I(e, t) {
  var r = Object.assign({}, e, t);
  if (t.hasOwnProperty("classes")) {
    r.classes = Object.assign({}, e.classes, t.classes);
    var n = ["direction", "type", "slide", "arrow", "nav"];
    n.forEach(function(s) {
      t.classes.hasOwnProperty(s) && (r.classes[s] = q(q({}, e.classes[s]), t.classes[s]));
    });
  }
  return t.hasOwnProperty("breakpoints") && (r.breakpoints = Object.assign({}, e.breakpoints, t.breakpoints)), r;
}
var gt = /* @__PURE__ */ function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    B(this, e), this.events = t, this.hop = t.hasOwnProperty;
  }
  return L(e, [{
    key: "on",
    value: function(r, n) {
      if (z(r)) {
        for (var s = 0; s < r.length; s++)
          this.on(r[s], n);
        return;
      }
      this.hop.call(this.events, r) || (this.events[r] = []);
      var i = this.events[r].push(n) - 1;
      return {
        remove: function() {
          delete this.events[r][i];
        }
      };
    }
    /**
     * Runs registered handlers for specified event.
     *
     * @param {String|Array} event
     * @param {Object=} context
     */
  }, {
    key: "emit",
    value: function(r, n) {
      if (z(r)) {
        for (var s = 0; s < r.length; s++)
          this.emit(r[s], n);
        return;
      }
      this.hop.call(this.events, r) && this.events[r].forEach(function(i) {
        i(n || {});
      });
    }
  }]), e;
}(), vt = /* @__PURE__ */ function() {
  function e(t) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    B(this, e), this._c = {}, this._t = [], this._e = new gt(), this.disabled = !1, this.selector = t, this.settings = I(ft, r), this.index = this.settings.startAt;
  }
  return L(e, [{
    key: "mount",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return this._e.emit("mount.before"), k(r) ? this._c = dt(this, r, this._e) : b("You need to provide a object on `mount()`"), this._e.emit("mount.after"), this;
    }
    /**
     * Collects an instance `translate` transformers.
     *
     * @param  {Array} transformers Collection of transformers.
     * @return {Void}
     */
  }, {
    key: "mutate",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return z(r) ? this._t = r : b("You need to provide a array on `mutate()`"), this;
    }
    /**
     * Updates glide with specified settings.
     *
     * @param {Object} settings
     * @return {Glide}
     */
  }, {
    key: "update",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return this.settings = I(this.settings, r), r.hasOwnProperty("startAt") && (this.index = r.startAt), this._e.emit("update"), this;
    }
    /**
     * Change slide with specified pattern. A pattern must be in the special format:
     * `>` - Move one forward
     * `<` - Move one backward
     * `={i}` - Go to {i} zero-based slide (eq. '=1', will go to second slide)
     * `>>` - Rewinds to end (last slide)
     * `<<` - Rewinds to start (first slide)
     * `|>` - Move one viewport forward
     * `|<` - Move one viewport backward
     *
     * @param {String} pattern
     * @return {Glide}
     */
  }, {
    key: "go",
    value: function(r) {
      return this._c.Run.make(r), this;
    }
    /**
     * Move track by specified distance.
     *
     * @param {String} distance
     * @return {Glide}
     */
  }, {
    key: "move",
    value: function(r) {
      return this._c.Transition.disable(), this._c.Move.make(r), this;
    }
    /**
     * Destroy instance and revert all changes done by this._c.
     *
     * @return {Glide}
     */
  }, {
    key: "destroy",
    value: function() {
      return this._e.emit("destroy"), this;
    }
    /**
     * Start instance autoplaying.
     *
     * @param {Boolean|Number} interval Run autoplaying with passed interval regardless of `autoplay` settings
     * @return {Glide}
     */
  }, {
    key: "play",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
      return r && (this.settings.autoplay = r), this._e.emit("play"), this;
    }
    /**
     * Stop instance autoplaying.
     *
     * @return {Glide}
     */
  }, {
    key: "pause",
    value: function() {
      return this._e.emit("pause"), this;
    }
    /**
     * Sets glide into a idle status.
     *
     * @return {Glide}
     */
  }, {
    key: "disable",
    value: function() {
      return this.disabled = !0, this;
    }
    /**
     * Sets glide into a active status.
     *
     * @return {Glide}
     */
  }, {
    key: "enable",
    value: function() {
      return this.disabled = !1, this;
    }
    /**
     * Adds cuutom event listener with handler.
     *
     * @param  {String|Array} event
     * @param  {Function} handler
     * @return {Glide}
     */
  }, {
    key: "on",
    value: function(r, n) {
      return this._e.on(r, n), this;
    }
    /**
     * Checks if glide is a precised type.
     *
     * @param  {String} name
     * @return {Boolean}
     */
  }, {
    key: "isType",
    value: function(r) {
      return this.settings.type === r;
    }
    /**
     * Gets value of the core options.
     *
     * @return {Object}
     */
  }, {
    key: "settings",
    get: function() {
      return this._o;
    },
    set: function(r) {
      k(r) ? this._o = r : b("Options must be an `object` instance.");
    }
    /**
     * Gets current index of the slider.
     *
     * @return {Object}
     */
  }, {
    key: "index",
    get: function() {
      return this._i;
    },
    set: function(r) {
      this._i = p(r);
    }
    /**
     * Gets type name of the slider.
     *
     * @return {String}
     */
  }, {
    key: "type",
    get: function() {
      return this.settings.type;
    }
    /**
     * Gets value of the idle status.
     *
     * @return {Boolean}
     */
  }, {
    key: "disabled",
    get: function() {
      return this._d;
    },
    set: function(r) {
      this._d = !!r;
    }
  }]), e;
}();
function pt(e, t, r) {
  var n = {
    /**
     * Initializes autorunning of the glide.
     *
     * @return {Void}
     */
    mount: function() {
      this._o = !1;
    },
    /**
     * Makes glides running based on the passed moving schema.
     *
     * @param {String} move
     */
    make: function(f) {
      var c = this;
      e.disabled || (!e.settings.waitForTransition || e.disable(), this.move = f, r.emit("run.before", this.move), this.calculate(), r.emit("run", this.move), t.Transition.after(function() {
        c.isStart() && r.emit("run.start", c.move), c.isEnd() && r.emit("run.end", c.move), c.isOffset() && (c._o = !1, r.emit("run.offset", c.move)), r.emit("run.after", c.move), e.enable();
      }));
    },
    /**
     * Calculates current index based on defined move.
     *
     * @return {Number|Undefined}
     */
    calculate: function() {
      var f = this.move, c = this.length, d = f.steps, l = f.direction, g = 1;
      if (l === "=") {
        if (e.settings.bound && p(d) > c) {
          e.index = c;
          return;
        }
        e.index = d;
        return;
      }
      if (l === ">" && d === ">") {
        e.index = c;
        return;
      }
      if (l === "<" && d === "<") {
        e.index = 0;
        return;
      }
      if (l === "|" && (g = e.settings.perView || 1), l === ">" || l === "|" && d === ">") {
        var m = s(g);
        m > c && (this._o = !0), e.index = i(m, g);
        return;
      }
      if (l === "<" || l === "|" && d === "<") {
        var v = a(g);
        v < 0 && (this._o = !0), e.index = o(v, g);
        return;
      }
      b("Invalid direction pattern [".concat(l).concat(d, "] has been used"));
    },
    /**
     * Checks if we are on the first slide.
     *
     * @return {Boolean}
     */
    isStart: function() {
      return e.index <= 0;
    },
    /**
     * Checks if we are on the last slide.
     *
     * @return {Boolean}
     */
    isEnd: function() {
      return e.index >= this.length;
    },
    /**
     * Checks if we are making a offset run.
     *
     * @param {String} direction
     * @return {Boolean}
     */
    isOffset: function() {
      var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      return f ? this._o ? f === "|>" ? this.move.direction === "|" && this.move.steps === ">" : f === "|<" ? this.move.direction === "|" && this.move.steps === "<" : this.move.direction === f : !1 : this._o;
    },
    /**
     * Checks if bound mode is active
     *
     * @return {Boolean}
     */
    isBound: function() {
      return e.isType("slider") && e.settings.focusAt !== "center" && e.settings.bound;
    }
  };
  function s(u) {
    var f = e.index;
    return e.isType("carousel") ? f + u : f + (u - f % u);
  }
  function i(u, f) {
    var c = n.length;
    return u <= c ? u : e.isType("carousel") ? u - (c + 1) : e.settings.rewind ? n.isBound() && !n.isEnd() ? c : 0 : n.isBound() ? c : Math.floor(c / f) * f;
  }
  function a(u) {
    var f = e.index;
    if (e.isType("carousel"))
      return f - u;
    var c = Math.ceil(f / u);
    return (c - 1) * u;
  }
  function o(u, f) {
    var c = n.length;
    return u >= 0 ? u : e.isType("carousel") ? u + (c + 1) : e.settings.rewind ? n.isBound() && n.isStart() ? c : Math.floor(c / f) * f : 0;
  }
  return h(n, "move", {
    /**
     * Gets value of the move schema.
     *
     * @returns {Object}
     */
    get: function() {
      return this._m;
    },
    /**
     * Sets value of the move schema.
     *
     * @returns {Object}
     */
    set: function(f) {
      var c = f.substr(1);
      this._m = {
        direction: f.substr(0, 1),
        steps: c ? p(c) ? p(c) : c : 0
      };
    }
  }), h(n, "length", {
    /**
     * Gets value of the running distance based
     * on zero-indexing number of slides.
     *
     * @return {Number}
     */
    get: function() {
      var f = e.settings, c = t.Html.slides.length;
      return this.isBound() ? c - 1 - (p(f.perView) - 1) + p(f.focusAt) : c - 1;
    }
  }), h(n, "offset", {
    /**
     * Gets status of the offsetting flag.
     *
     * @return {Boolean}
     */
    get: function() {
      return this._o;
    }
  }), n;
}
function K() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function M(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n, s, i, a, o = 0, u = function() {
    o = r.leading === !1 ? 0 : K(), n = null, a = e.apply(s, i), n || (s = i = null);
  }, f = function() {
    var d = K();
    !o && r.leading === !1 && (o = d);
    var l = t - (d - o);
    return s = this, i = arguments, l <= 0 || l > t ? (n && (clearTimeout(n), n = null), o = d, a = e.apply(s, i), n || (s = i = null)) : !n && r.trailing !== !1 && (n = setTimeout(u, l)), a;
  };
  return f.cancel = function() {
    clearTimeout(n), o = 0, n = s = i = null;
  }, f;
}
var A = {
  ltr: ["marginLeft", "marginRight"],
  rtl: ["marginRight", "marginLeft"]
};
function mt(e, t, r) {
  var n = {
    /**
     * Applies gaps between slides. First and last
     * slides do not receive it's edge margins.
     *
     * @param {HTMLCollection} slides
     * @return {Void}
     */
    apply: function(i) {
      for (var a = 0, o = i.length; a < o; a++) {
        var u = i[a].style, f = t.Direction.value;
        a !== 0 ? u[A[f][0]] = "".concat(this.value / 2, "px") : u[A[f][0]] = "", a !== i.length - 1 ? u[A[f][1]] = "".concat(this.value / 2, "px") : u[A[f][1]] = "";
      }
    },
    /**
     * Removes gaps from the slides.
     *
     * @param {HTMLCollection} slides
     * @returns {Void}
    */
    remove: function(i) {
      for (var a = 0, o = i.length; a < o; a++) {
        var u = i[a].style;
        u.marginLeft = "", u.marginRight = "";
      }
    }
  };
  return h(n, "value", {
    /**
     * Gets value of the gap.
     *
     * @returns {Number}
     */
    get: function() {
      return p(e.settings.gap);
    }
  }), h(n, "grow", {
    /**
     * Gets additional dimensions value caused by gaps.
     * Used to increase width of the slides wrapper.
     *
     * @returns {Number}
     */
    get: function() {
      return n.value * t.Sizes.length;
    }
  }), h(n, "reductor", {
    /**
     * Gets reduction value caused by gaps.
     * Used to subtract width of the slides.
     *
     * @returns {Number}
     */
    get: function() {
      var i = e.settings.perView;
      return n.value * (i - 1) / i;
    }
  }), r.on(["build.after", "update"], M(function() {
    n.apply(t.Html.wrapper.children);
  }, 30)), r.on("destroy", function() {
    n.remove(t.Html.wrapper.children);
  }), n;
}
function C(e) {
  if (e && e.parentNode) {
    for (var t = e.parentNode.firstChild, r = []; t; t = t.nextSibling)
      t.nodeType === 1 && t !== e && r.push(t);
    return r;
  }
  return [];
}
function E(e) {
  return Array.prototype.slice.call(e);
}
var bt = '[data-glide-el="track"]';
function yt(e, t, r) {
  var n = {
    /**
     * Setup slider HTML nodes.
     *
     * @param {Glide} glide
     */
    mount: function() {
      this.root = e.selector, this.track = this.root.querySelector(bt), this.collectSlides();
    },
    /**
     * Collect slides
     */
    collectSlides: function() {
      this.slides = E(this.wrapper.children).filter(function(i) {
        return !i.classList.contains(e.settings.classes.slide.clone);
      });
    }
  };
  return h(n, "root", {
    /**
     * Gets node of the glide main element.
     *
     * @return {Object}
     */
    get: function() {
      return n._r;
    },
    /**
     * Sets node of the glide main element.
     *
     * @return {Object}
     */
    set: function(i) {
      D(i) && (i = document.querySelector(i)), i !== null ? n._r = i : b("Root element must be a existing Html node");
    }
  }), h(n, "track", {
    /**
     * Gets node of the glide track with slides.
     *
     * @return {Object}
     */
    get: function() {
      return n._t;
    },
    /**
     * Sets node of the glide track with slides.
     *
     * @return {Object}
     */
    set: function(i) {
      n._t = i;
    }
  }), h(n, "wrapper", {
    /**
     * Gets node of the slides wrapper.
     *
     * @return {Object}
     */
    get: function() {
      return n.track.children[0];
    }
  }), r.on("update", function() {
    n.collectSlides();
  }), n;
}
function wt(e, t, r) {
  var n = {
    /**
     * Setups how much to peek based on settings.
     *
     * @return {Void}
     */
    mount: function() {
      this.value = e.settings.peek;
    }
  };
  return h(n, "value", {
    /**
     * Gets value of the peek.
     *
     * @returns {Number|Object}
     */
    get: function() {
      return n._v;
    },
    /**
     * Sets value of the peek.
     *
     * @param {Number|Object} value
     * @return {Void}
     */
    set: function(i) {
      k(i) ? (i.before = p(i.before), i.after = p(i.after)) : i = p(i), n._v = i;
    }
  }), h(n, "reductor", {
    /**
     * Gets reduction value caused by peek.
     *
     * @returns {Number}
     */
    get: function() {
      var i = n.value, a = e.settings.perView;
      return k(i) ? i.before / a + i.after / a : i * 2 / a;
    }
  }), r.on(["resize", "update"], function() {
    n.mount();
  }), n;
}
function _t(e, t, r) {
  var n = {
    /**
     * Constructs move component.
     *
     * @returns {Void}
     */
    mount: function() {
      this._o = 0;
    },
    /**
     * Calculates a movement value based on passed offset and currently active index.
     *
     * @param  {Number} offset
     * @return {Void}
     */
    make: function() {
      var i = this, a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      this.offset = a, r.emit("move", {
        movement: this.value
      }), t.Transition.after(function() {
        r.emit("move.after", {
          movement: i.value
        });
      });
    }
  };
  return h(n, "offset", {
    /**
     * Gets an offset value used to modify current translate.
     *
     * @return {Object}
     */
    get: function() {
      return n._o;
    },
    /**
     * Sets an offset value used to modify current translate.
     *
     * @return {Object}
     */
    set: function(i) {
      n._o = Z(i) ? 0 : p(i);
    }
  }), h(n, "translate", {
    /**
     * Gets a raw movement value.
     *
     * @return {Number}
     */
    get: function() {
      return t.Sizes.slideWidth * e.index;
    }
  }), h(n, "value", {
    /**
     * Gets an actual movement value corrected by offset.
     *
     * @return {Number}
     */
    get: function() {
      var i = this.offset, a = this.translate;
      return t.Direction.is("rtl") ? a + i : a - i;
    }
  }), r.on(["build.before", "run"], function() {
    n.make();
  }), n;
}
function St(e, t, r) {
  var n = {
    /**
     * Setups dimensions of slides.
     *
     * @return {Void}
     */
    setupSlides: function() {
      for (var i = "".concat(this.slideWidth, "px"), a = t.Html.slides, o = 0; o < a.length; o++)
        a[o].style.width = i;
    },
    /**
     * Setups dimensions of slides wrapper.
     *
     * @return {Void}
     */
    setupWrapper: function() {
      t.Html.wrapper.style.width = "".concat(this.wrapperSize, "px");
    },
    /**
     * Removes applied styles from HTML elements.
     *
     * @returns {Void}
     */
    remove: function() {
      for (var i = t.Html.slides, a = 0; a < i.length; a++)
        i[a].style.width = "";
      t.Html.wrapper.style.width = "";
    }
  };
  return h(n, "length", {
    /**
     * Gets count number of the slides.
     *
     * @return {Number}
     */
    get: function() {
      return t.Html.slides.length;
    }
  }), h(n, "width", {
    /**
     * Gets width value of the slider (visible area).
     *
     * @return {Number}
     */
    get: function() {
      return t.Html.track.offsetWidth;
    }
  }), h(n, "wrapperSize", {
    /**
     * Gets size of the slides wrapper.
     *
     * @return {Number}
     */
    get: function() {
      return n.slideWidth * n.length + t.Gaps.grow + t.Clones.grow;
    }
  }), h(n, "slideWidth", {
    /**
     * Gets width value of a single slide.
     *
     * @return {Number}
     */
    get: function() {
      return n.width / e.settings.perView - t.Peek.reductor - t.Gaps.reductor;
    }
  }), r.on(["build.before", "resize", "update"], function() {
    n.setupSlides(), n.setupWrapper();
  }), r.on("destroy", function() {
    n.remove();
  }), n;
}
function Ot(e, t, r) {
  var n = {
    /**
     * Init glide building. Adds classes, sets
     * dimensions and setups initial state.
     *
     * @return {Void}
     */
    mount: function() {
      r.emit("build.before"), this.typeClass(), this.activeClass(), r.emit("build.after");
    },
    /**
     * Adds `type` class to the glide element.
     *
     * @return {Void}
     */
    typeClass: function() {
      t.Html.root.classList.add(e.settings.classes.type[e.settings.type]);
    },
    /**
     * Sets active class to current slide.
     *
     * @return {Void}
     */
    activeClass: function() {
      var i = e.settings.classes, a = t.Html.slides[e.index];
      a && (a.classList.add(i.slide.active), C(a).forEach(function(o) {
        o.classList.remove(i.slide.active);
      }));
    },
    /**
     * Removes HTML classes applied at building.
     *
     * @return {Void}
     */
    removeClasses: function() {
      var i = e.settings.classes, a = i.type, o = i.slide;
      t.Html.root.classList.remove(a[e.settings.type]), t.Html.slides.forEach(function(u) {
        u.classList.remove(o.active);
      });
    }
  };
  return r.on(["destroy", "update"], function() {
    n.removeClasses();
  }), r.on(["resize", "update"], function() {
    n.mount();
  }), r.on("move.after", function() {
    n.activeClass();
  }), n;
}
function Tt(e, t, r) {
  var n = {
    /**
     * Create pattern map and collect slides to be cloned.
     */
    mount: function() {
      this.items = [], e.isType("carousel") && (this.items = this.collect());
    },
    /**
     * Collect clones with pattern.
     *
     * @return {[]}
     */
    collect: function() {
      var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], a = t.Html.slides, o = e.settings, u = o.perView, f = o.classes, c = o.cloningRatio;
      if (a.length > 0)
        for (var d = +!!e.settings.peek, l = u + d + Math.round(u / 2), g = a.slice(0, l).reverse(), m = a.slice(l * -1), v = 0; v < Math.max(c, Math.floor(u / a.length)); v++) {
          for (var y = 0; y < g.length; y++) {
            var w = g[y].cloneNode(!0);
            w.classList.add(f.slide.clone), i.push(w);
          }
          for (var _ = 0; _ < m.length; _++) {
            var O = m[_].cloneNode(!0);
            O.classList.add(f.slide.clone), i.unshift(O);
          }
        }
      return i;
    },
    /**
     * Append cloned slides with generated pattern.
     *
     * @return {Void}
     */
    append: function() {
      for (var i = this.items, a = t.Html, o = a.wrapper, u = a.slides, f = Math.floor(i.length / 2), c = i.slice(0, f).reverse(), d = i.slice(f * -1).reverse(), l = "".concat(t.Sizes.slideWidth, "px"), g = 0; g < d.length; g++)
        o.appendChild(d[g]);
      for (var m = 0; m < c.length; m++)
        o.insertBefore(c[m], u[0]);
      for (var v = 0; v < i.length; v++)
        i[v].style.width = l;
    },
    /**
     * Remove all cloned slides.
     *
     * @return {Void}
     */
    remove: function() {
      for (var i = this.items, a = 0; a < i.length; a++)
        t.Html.wrapper.removeChild(i[a]);
    }
  };
  return h(n, "grow", {
    /**
     * Gets additional dimensions value caused by clones.
     *
     * @return {Number}
     */
    get: function() {
      return (t.Sizes.slideWidth + t.Gaps.value) * n.items.length;
    }
  }), r.on("update", function() {
    n.remove(), n.mount(), n.append();
  }), r.on("build.before", function() {
    e.isType("carousel") && n.append();
  }), r.on("destroy", function() {
    n.remove();
  }), n;
}
var S = /* @__PURE__ */ function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    B(this, e), this.listeners = t;
  }
  return L(e, [{
    key: "on",
    value: function(r, n, s) {
      var i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
      D(r) && (r = [r]);
      for (var a = 0; a < r.length; a++)
        this.listeners[r[a]] = s, n.addEventListener(r[a], this.listeners[r[a]], i);
    }
    /**
     * Removes event listeners from arrows HTML elements.
     *
     * @param  {String|Array} events
     * @param  {Element|Window|Document} el
     * @param  {Boolean|Object} capture
     * @return {Void}
     */
  }, {
    key: "off",
    value: function(r, n) {
      var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      D(r) && (r = [r]);
      for (var i = 0; i < r.length; i++)
        n.removeEventListener(r[i], this.listeners[r[i]], s);
    }
    /**
     * Destroy collected listeners.
     *
     * @returns {Void}
     */
  }, {
    key: "destroy",
    value: function() {
      delete this.listeners;
    }
  }]), e;
}();
function kt(e, t, r) {
  var n = new S(), s = {
    /**
     * Initializes window bindings.
     */
    mount: function() {
      this.bind();
    },
    /**
     * Binds `rezsize` listener to the window.
     * It's a costly event, so we are debouncing it.
     *
     * @return {Void}
     */
    bind: function() {
      n.on("resize", window, M(function() {
        r.emit("resize");
      }, e.settings.throttle));
    },
    /**
     * Unbinds listeners from the window.
     *
     * @return {Void}
     */
    unbind: function() {
      n.off("resize", window);
    }
  };
  return r.on("destroy", function() {
    s.unbind(), n.destroy();
  }), s;
}
var At = ["ltr", "rtl"], Rt = {
  ">": "<",
  "<": ">",
  "=": "="
};
function Ht(e, t, r) {
  var n = {
    /**
     * Setups gap value based on settings.
     *
     * @return {Void}
     */
    mount: function() {
      this.value = e.settings.direction;
    },
    /**
     * Resolves pattern based on direction value
     *
     * @param {String} pattern
     * @returns {String}
     */
    resolve: function(i) {
      var a = i.slice(0, 1);
      return this.is("rtl") ? i.split(a).join(Rt[a]) : i;
    },
    /**
     * Checks value of direction mode.
     *
     * @param {String} direction
     * @returns {Boolean}
     */
    is: function(i) {
      return this.value === i;
    },
    /**
     * Applies direction class to the root HTML element.
     *
     * @return {Void}
     */
    addClass: function() {
      t.Html.root.classList.add(e.settings.classes.direction[this.value]);
    },
    /**
     * Removes direction class from the root HTML element.
     *
     * @return {Void}
     */
    removeClass: function() {
      t.Html.root.classList.remove(e.settings.classes.direction[this.value]);
    }
  };
  return h(n, "value", {
    /**
     * Gets value of the direction.
     *
     * @returns {Number}
     */
    get: function() {
      return n._v;
    },
    /**
     * Sets value of the direction.
     *
     * @param {String} value
     * @return {Void}
     */
    set: function(i) {
      At.indexOf(i) > -1 ? n._v = i : b("Direction value must be `ltr` or `rtl`");
    }
  }), r.on(["destroy", "update"], function() {
    n.removeClass();
  }), r.on("update", function() {
    n.mount();
  }), r.on(["build.before", "update"], function() {
    n.addClass();
  }), n;
}
function xt(e, t) {
  return {
    /**
     * Negates the passed translate if glide is in RTL option.
     *
     * @param  {Number} translate
     * @return {Number}
     */
    modify: function(n) {
      return t.Direction.is("rtl") ? -n : n;
    }
  };
}
function Pt(e, t) {
  return {
    /**
     * Modifies passed translate value with number in the `gap` settings.
     *
     * @param  {Number} translate
     * @return {Number}
     */
    modify: function(n) {
      var s = Math.floor(n / t.Sizes.slideWidth);
      return n + t.Gaps.value * s;
    }
  };
}
function Bt(e, t) {
  return {
    /**
     * Adds to the passed translate width of the half of clones.
     *
     * @param  {Number} translate
     * @return {Number}
     */
    modify: function(n) {
      return n + t.Clones.grow / 2;
    }
  };
}
function Lt(e, t) {
  return {
    /**
     * Modifies passed translate value with a `peek` setting.
     *
     * @param  {Number} translate
     * @return {Number}
     */
    modify: function(n) {
      if (e.settings.focusAt >= 0) {
        var s = t.Peek.value;
        return k(s) ? n - s.before : n - s;
      }
      return n;
    }
  };
}
function Mt(e, t) {
  return {
    /**
     * Modifies passed translate value with index in the `focusAt` setting.
     *
     * @param  {Number} translate
     * @return {Number}
     */
    modify: function(n) {
      var s = t.Gaps.value, i = t.Sizes.width, a = e.settings.focusAt, o = t.Sizes.slideWidth;
      return a === "center" ? n - (i / 2 - o / 2) : n - o * a - s * a;
    }
  };
}
function jt(e, t, r) {
  var n = [Pt, Bt, Lt, Mt].concat(e._t, [xt]);
  return {
    /**
     * Piplines translate value with registered transformers.
     *
     * @param  {Number} translate
     * @return {Number}
     */
    mutate: function(i) {
      for (var a = 0; a < n.length; a++) {
        var o = n[a];
        P(o) && P(o().modify) ? i = o(e, t, r).modify(i) : b("Transformer should be a function that returns an object with `modify()` method");
      }
      return i;
    }
  };
}
function Dt(e, t, r) {
  var n = {
    /**
     * Sets value of translate on HTML element.
     *
     * @param {Number} value
     * @return {Void}
     */
    set: function(i) {
      var a = jt(e, t).mutate(i), o = "translate3d(".concat(-1 * a, "px, 0px, 0px)");
      t.Html.wrapper.style.mozTransform = o, t.Html.wrapper.style.webkitTransform = o, t.Html.wrapper.style.transform = o;
    },
    /**
     * Removes value of translate from HTML element.
     *
     * @return {Void}
     */
    remove: function() {
      t.Html.wrapper.style.transform = "";
    },
    /**
     * @return {number}
     */
    getStartIndex: function() {
      var i = t.Sizes.length, a = e.index, o = e.settings.perView;
      return t.Run.isOffset(">") || t.Run.isOffset("|>") ? i + (a - o) : (a + o) % i;
    },
    /**
     * @return {number}
     */
    getTravelDistance: function() {
      var i = t.Sizes.slideWidth * e.settings.perView;
      return t.Run.isOffset(">") || t.Run.isOffset("|>") ? i * -1 : i;
    }
  };
  return r.on("move", function(s) {
    if (!e.isType("carousel") || !t.Run.isOffset())
      return n.set(s.movement);
    t.Transition.after(function() {
      r.emit("translate.jump"), n.set(t.Sizes.slideWidth * e.index);
    });
    var i = t.Sizes.slideWidth * t.Translate.getStartIndex();
    return n.set(i - t.Translate.getTravelDistance());
  }), r.on("destroy", function() {
    n.remove();
  }), n;
}
function zt(e, t, r) {
  var n = !1, s = {
    /**
     * Composes string of the CSS transition.
     *
     * @param {String} property
     * @return {String}
     */
    compose: function(a) {
      var o = e.settings;
      return n ? "".concat(a, " 0ms ").concat(o.animationTimingFunc) : "".concat(a, " ").concat(this.duration, "ms ").concat(o.animationTimingFunc);
    },
    /**
     * Sets value of transition on HTML element.
     *
     * @param {String=} property
     * @return {Void}
     */
    set: function() {
      var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
      t.Html.wrapper.style.transition = this.compose(a);
    },
    /**
     * Removes value of transition from HTML element.
     *
     * @return {Void}
     */
    remove: function() {
      t.Html.wrapper.style.transition = "";
    },
    /**
     * Runs callback after animation.
     *
     * @param  {Function} callback
     * @return {Void}
     */
    after: function(a) {
      setTimeout(function() {
        a();
      }, this.duration);
    },
    /**
     * Enable transition.
     *
     * @return {Void}
     */
    enable: function() {
      n = !1, this.set();
    },
    /**
     * Disable transition.
     *
     * @return {Void}
     */
    disable: function() {
      n = !0, this.set();
    }
  };
  return h(s, "duration", {
    /**
     * Gets duration of the transition based
     * on currently running animation type.
     *
     * @return {Number}
     */
    get: function() {
      var a = e.settings;
      return e.isType("slider") && t.Run.offset ? a.rewindDuration : a.animationDuration;
    }
  }), r.on("move", function() {
    s.set();
  }), r.on(["build.before", "resize", "translate.jump"], function() {
    s.disable();
  }), r.on("run", function() {
    s.enable();
  }), r.on("destroy", function() {
    s.remove();
  }), s;
}
var G = !1;
try {
  var X = Object.defineProperty({}, "passive", {
    get: function() {
      G = !0;
    }
  });
  window.addEventListener("testPassive", null, X), window.removeEventListener("testPassive", null, X);
} catch {
}
var V = G, R = ["touchstart", "mousedown"], Y = ["touchmove", "mousemove"], $ = ["touchend", "touchcancel", "mouseup", "mouseleave"], U = ["mousedown", "mousemove", "mouseup", "mouseleave"];
function It(e, t, r) {
  var n = new S(), s = 0, i = 0, a = 0, o = !1, u = V ? {
    passive: !0
  } : !1, f = {
    /**
     * Initializes swipe bindings.
     *
     * @return {Void}
     */
    mount: function() {
      this.bindSwipeStart();
    },
    /**
     * Handler for `swipestart` event. Calculates entry points of the user's tap.
     *
     * @param {Object} event
     * @return {Void}
     */
    start: function(d) {
      if (!o && !e.disabled) {
        this.disable();
        var l = this.touches(d);
        s = null, i = p(l.pageX), a = p(l.pageY), this.bindSwipeMove(), this.bindSwipeEnd(), r.emit("swipe.start");
      }
    },
    /**
     * Handler for `swipemove` event. Calculates user's tap angle and distance.
     *
     * @param {Object} event
     */
    move: function(d) {
      if (!e.disabled) {
        var l = e.settings, g = l.touchAngle, m = l.touchRatio, v = l.classes, y = this.touches(d), w = p(y.pageX) - i, _ = p(y.pageY) - a, O = Math.abs(w << 2), W = Math.abs(_ << 2), tt = Math.sqrt(O + W), et = Math.sqrt(W);
        if (s = Math.asin(et / tt), s * 180 / Math.PI < g)
          d.stopPropagation(), t.Move.make(w * lt(m)), t.Html.root.classList.add(v.dragging), r.emit("swipe.move");
        else
          return !1;
      }
    },
    /**
     * Handler for `swipeend` event. Finitializes user's tap and decides about glide move.
     *
     * @param {Object} event
     * @return {Void}
     */
    end: function(d) {
      if (!e.disabled) {
        var l = e.settings, g = l.perSwipe, m = l.touchAngle, v = l.classes, y = this.touches(d), w = this.threshold(d), _ = y.pageX - i, O = s * 180 / Math.PI;
        this.enable(), _ > w && O < m ? t.Run.make(t.Direction.resolve("".concat(g, "<"))) : _ < -w && O < m ? t.Run.make(t.Direction.resolve("".concat(g, ">"))) : t.Move.make(), t.Html.root.classList.remove(v.dragging), this.unbindSwipeMove(), this.unbindSwipeEnd(), r.emit("swipe.end");
      }
    },
    /**
     * Binds swipe's starting event.
     *
     * @return {Void}
     */
    bindSwipeStart: function() {
      var d = this, l = e.settings, g = l.swipeThreshold, m = l.dragThreshold;
      g && n.on(R[0], t.Html.wrapper, function(v) {
        d.start(v);
      }, u), m && n.on(R[1], t.Html.wrapper, function(v) {
        d.start(v);
      }, u);
    },
    /**
     * Unbinds swipe's starting event.
     *
     * @return {Void}
     */
    unbindSwipeStart: function() {
      n.off(R[0], t.Html.wrapper, u), n.off(R[1], t.Html.wrapper, u);
    },
    /**
     * Binds swipe's moving event.
     *
     * @return {Void}
     */
    bindSwipeMove: function() {
      var d = this;
      n.on(Y, t.Html.wrapper, M(function(l) {
        d.move(l);
      }, e.settings.throttle), u);
    },
    /**
     * Unbinds swipe's moving event.
     *
     * @return {Void}
     */
    unbindSwipeMove: function() {
      n.off(Y, t.Html.wrapper, u);
    },
    /**
     * Binds swipe's ending event.
     *
     * @return {Void}
     */
    bindSwipeEnd: function() {
      var d = this;
      n.on($, t.Html.wrapper, function(l) {
        d.end(l);
      });
    },
    /**
     * Unbinds swipe's ending event.
     *
     * @return {Void}
     */
    unbindSwipeEnd: function() {
      n.off($, t.Html.wrapper);
    },
    /**
     * Normalizes event touches points accorting to different types.
     *
     * @param {Object} event
     */
    touches: function(d) {
      return U.indexOf(d.type) > -1 ? d : d.touches[0] || d.changedTouches[0];
    },
    /**
     * Gets value of minimum swipe distance settings based on event type.
     *
     * @return {Number}
     */
    threshold: function(d) {
      var l = e.settings;
      return U.indexOf(d.type) > -1 ? l.dragThreshold : l.swipeThreshold;
    },
    /**
     * Enables swipe event.
     *
     * @return {self}
     */
    enable: function() {
      return o = !1, t.Transition.enable(), this;
    },
    /**
     * Disables swipe event.
     *
     * @return {self}
     */
    disable: function() {
      return o = !0, t.Transition.disable(), this;
    }
  };
  return r.on("build.after", function() {
    t.Html.root.classList.add(e.settings.classes.swipeable);
  }), r.on("destroy", function() {
    f.unbindSwipeStart(), f.unbindSwipeMove(), f.unbindSwipeEnd(), n.destroy();
  }), f;
}
function Et(e, t, r) {
  var n = new S(), s = {
    /**
     * Binds listener to glide wrapper.
     *
     * @return {Void}
     */
    mount: function() {
      this.bind();
    },
    /**
     * Binds `dragstart` event on wrapper to prevent dragging images.
     *
     * @return {Void}
     */
    bind: function() {
      n.on("dragstart", t.Html.wrapper, this.dragstart);
    },
    /**
     * Unbinds `dragstart` event on wrapper.
     *
     * @return {Void}
     */
    unbind: function() {
      n.off("dragstart", t.Html.wrapper);
    },
    /**
     * Event handler. Prevents dragging.
     *
     * @return {Void}
     */
    dragstart: function(a) {
      a.preventDefault();
    }
  };
  return r.on("destroy", function() {
    s.unbind(), n.destroy();
  }), s;
}
function Vt(e, t, r) {
  var n = new S(), s = !1, i = !1, a = {
    /**
     * Setups a initial state of anchors component.
     *
     * @returns {Void}
     */
    mount: function() {
      this._a = t.Html.wrapper.querySelectorAll("a"), this.bind();
    },
    /**
     * Binds events to anchors inside a track.
     *
     * @return {Void}
     */
    bind: function() {
      n.on("click", t.Html.wrapper, this.click);
    },
    /**
     * Unbinds events attached to anchors inside a track.
     *
     * @return {Void}
     */
    unbind: function() {
      n.off("click", t.Html.wrapper);
    },
    /**
     * Handler for click event. Prevents clicks when glide is in `prevent` status.
     *
     * @param  {Object} event
     * @return {Void}
     */
    click: function(u) {
      i && (u.stopPropagation(), u.preventDefault());
    },
    /**
     * Detaches anchors click event inside glide.
     *
     * @return {self}
     */
    detach: function() {
      if (i = !0, !s) {
        for (var u = 0; u < this.items.length; u++)
          this.items[u].draggable = !1;
        s = !0;
      }
      return this;
    },
    /**
     * Attaches anchors click events inside glide.
     *
     * @return {self}
     */
    attach: function() {
      if (i = !1, s) {
        for (var u = 0; u < this.items.length; u++)
          this.items[u].draggable = !0;
        s = !1;
      }
      return this;
    }
  };
  return h(a, "items", {
    /**
     * Gets collection of the arrows HTML elements.
     *
     * @return {HTMLElement[]}
     */
    get: function() {
      return a._a;
    }
  }), r.on("swipe.move", function() {
    a.detach();
  }), r.on("swipe.end", function() {
    t.Transition.after(function() {
      a.attach();
    });
  }), r.on("destroy", function() {
    a.attach(), a.unbind(), n.destroy();
  }), a;
}
var Nt = '[data-glide-el="controls[nav]"]', N = '[data-glide-el^="controls"]', Wt = "".concat(N, ' [data-glide-dir*="<"]'), Ft = "".concat(N, ' [data-glide-dir*=">"]');
function qt(e, t, r) {
  var n = new S(), s = V ? {
    passive: !0
  } : !1, i = {
    /**
     * Inits arrows. Binds events listeners
     * to the arrows HTML elements.
     *
     * @return {Void}
     */
    mount: function() {
      this._n = t.Html.root.querySelectorAll(Nt), this._c = t.Html.root.querySelectorAll(N), this._arrowControls = {
        previous: t.Html.root.querySelectorAll(Wt),
        next: t.Html.root.querySelectorAll(Ft)
      }, this.addBindings();
    },
    /**
     * Sets active class to current slide.
     *
     * @return {Void}
     */
    setActive: function() {
      for (var o = 0; o < this._n.length; o++)
        this.addClass(this._n[o].children);
    },
    /**
     * Removes active class to current slide.
     *
     * @return {Void}
     */
    removeActive: function() {
      for (var o = 0; o < this._n.length; o++)
        this.removeClass(this._n[o].children);
    },
    /**
     * Toggles active class on items inside navigation.
     *
     * @param  {HTMLElement} controls
     * @return {Void}
     */
    addClass: function(o) {
      var u = e.settings, f = o[e.index];
      f && (f.classList.add(u.classes.nav.active), C(f).forEach(function(c) {
        c.classList.remove(u.classes.nav.active);
      }));
    },
    /**
     * Removes active class from active control.
     *
     * @param  {HTMLElement} controls
     * @return {Void}
     */
    removeClass: function(o) {
      var u = o[e.index];
      u == null || u.classList.remove(e.settings.classes.nav.active);
    },
    /**
     * Calculates, removes or adds `Glide.settings.classes.disabledArrow` class on the control arrows
     */
    setArrowState: function() {
      if (!e.settings.rewind) {
        var o = i._arrowControls.next, u = i._arrowControls.previous;
        this.resetArrowState(o, u), e.index === 0 && this.disableArrow(u), e.index === t.Run.length && this.disableArrow(o);
      }
    },
    /**
     * Removes `Glide.settings.classes.disabledArrow` from given NodeList elements
     *
     * @param {NodeList[]} lists
     */
    resetArrowState: function() {
      for (var o = e.settings, u = arguments.length, f = new Array(u), c = 0; c < u; c++)
        f[c] = arguments[c];
      f.forEach(function(d) {
        E(d).forEach(function(l) {
          l.classList.remove(o.classes.arrow.disabled);
        });
      });
    },
    /**
     * Adds `Glide.settings.classes.disabledArrow` to given NodeList elements
     *
     * @param {NodeList[]} lists
     */
    disableArrow: function() {
      for (var o = e.settings, u = arguments.length, f = new Array(u), c = 0; c < u; c++)
        f[c] = arguments[c];
      f.forEach(function(d) {
        E(d).forEach(function(l) {
          l.classList.add(o.classes.arrow.disabled);
        });
      });
    },
    /**
     * Adds handles to the each group of controls.
     *
     * @return {Void}
     */
    addBindings: function() {
      for (var o = 0; o < this._c.length; o++)
        this.bind(this._c[o].children);
    },
    /**
     * Removes handles from the each group of controls.
     *
     * @return {Void}
     */
    removeBindings: function() {
      for (var o = 0; o < this._c.length; o++)
        this.unbind(this._c[o].children);
    },
    /**
     * Binds events to arrows HTML elements.
     *
     * @param {HTMLCollection} elements
     * @return {Void}
     */
    bind: function(o) {
      for (var u = 0; u < o.length; u++)
        n.on("click", o[u], this.click), n.on("touchstart", o[u], this.click, s);
    },
    /**
     * Unbinds events binded to the arrows HTML elements.
     *
     * @param {HTMLCollection} elements
     * @return {Void}
     */
    unbind: function(o) {
      for (var u = 0; u < o.length; u++)
        n.off(["click", "touchstart"], o[u]);
    },
    /**
     * Handles `click` event on the arrows HTML elements.
     * Moves slider in direction given via the
     * `data-glide-dir` attribute.
     *
     * @param {Object} event
     * @return {void}
     */
    click: function(o) {
      !V && o.type === "touchstart" && o.preventDefault();
      var u = o.currentTarget.getAttribute("data-glide-dir");
      t.Run.make(t.Direction.resolve(u));
    }
  };
  return h(i, "items", {
    /**
     * Gets collection of the controls HTML elements.
     *
     * @return {HTMLElement[]}
     */
    get: function() {
      return i._c;
    }
  }), r.on(["mount.after", "move.after"], function() {
    i.setActive();
  }), r.on(["mount.after", "run"], function() {
    i.setArrowState();
  }), r.on("destroy", function() {
    i.removeBindings(), i.removeActive(), n.destroy();
  }), i;
}
function Kt(e, t, r) {
  var n = new S(), s = {
    /**
     * Binds keyboard events on component mount.
     *
     * @return {Void}
     */
    mount: function() {
      e.settings.keyboard && this.bind();
    },
    /**
     * Adds keyboard press events.
     *
     * @return {Void}
     */
    bind: function() {
      n.on("keyup", document, this.press);
    },
    /**
     * Removes keyboard press events.
     *
     * @return {Void}
     */
    unbind: function() {
      n.off("keyup", document);
    },
    /**
     * Handles keyboard's arrows press and moving glide foward and backward.
     *
     * @param  {Object} event
     * @return {Void}
     */
    press: function(a) {
      var o = e.settings.perSwipe, u = {
        ArrowRight: ">",
        ArrowLeft: "<"
      };
      ["ArrowRight", "ArrowLeft"].includes(a.code) && t.Run.make(t.Direction.resolve("".concat(o).concat(u[a.code])));
    }
  };
  return r.on(["destroy", "update"], function() {
    s.unbind();
  }), r.on("update", function() {
    s.mount();
  }), r.on("destroy", function() {
    n.destroy();
  }), s;
}
function Xt(e, t, r) {
  var n = new S(), s = {
    /**
     * Initializes autoplaying and events.
     *
     * @return {Void}
     */
    mount: function() {
      this.enable(), this.start(), e.settings.hoverpause && this.bind();
    },
    /**
     * Enables autoplaying
     *
     * @returns {Void}
     */
    enable: function() {
      this._e = !0;
    },
    /**
     * Disables autoplaying.
     *
     * @returns {Void}
     */
    disable: function() {
      this._e = !1;
    },
    /**
     * Starts autoplaying in configured interval.
     *
     * @param {Boolean|Number} force Run autoplaying with passed interval regardless of `autoplay` settings
     * @return {Void}
     */
    start: function() {
      var a = this;
      this._e && (this.enable(), e.settings.autoplay && Z(this._i) && (this._i = setInterval(function() {
        a.stop(), t.Run.make(">"), a.start(), r.emit("autoplay");
      }, this.time)));
    },
    /**
     * Stops autorunning of the glide.
     *
     * @return {Void}
     */
    stop: function() {
      this._i = clearInterval(this._i);
    },
    /**
     * Stops autoplaying while mouse is over glide's area.
     *
     * @return {Void}
     */
    bind: function() {
      var a = this;
      n.on("mouseover", t.Html.root, function() {
        a._e && a.stop();
      }), n.on("mouseout", t.Html.root, function() {
        a._e && a.start();
      });
    },
    /**
     * Unbind mouseover events.
     *
     * @returns {Void}
     */
    unbind: function() {
      n.off(["mouseover", "mouseout"], t.Html.root);
    }
  };
  return h(s, "time", {
    /**
     * Gets time period value for the autoplay interval. Prioritizes
     * times in `data-glide-autoplay` attrubutes over options.
     *
     * @return {Number}
     */
    get: function() {
      var a = t.Html.slides[e.index].getAttribute("data-glide-autoplay");
      return p(a || e.settings.autoplay);
    }
  }), r.on(["destroy", "update"], function() {
    s.unbind();
  }), r.on(["run.before", "swipe.start", "update"], function() {
    s.stop();
  }), r.on(["pause", "destroy"], function() {
    s.disable(), s.stop();
  }), r.on(["run.after", "swipe.end"], function() {
    s.start();
  }), r.on(["play"], function() {
    s.enable(), s.start();
  }), r.on("update", function() {
    s.mount();
  }), r.on("destroy", function() {
    n.destroy();
  }), s;
}
function J(e) {
  return k(e) ? ht(e) : (b("Breakpoints option must be an object"), {});
}
function Yt(e, t, r) {
  var n = new S(), s = e.settings, i = J(s.breakpoints), a = Object.assign({}, s), o = {
    /**
     * Matches settings for currectly matching media breakpoint.
     *
     * @param {Object} points
     * @returns {Object}
     */
    match: function(f) {
      if (typeof window.matchMedia < "u") {
        for (var c in f)
          if (f.hasOwnProperty(c) && window.matchMedia("(max-width: ".concat(c, "px)")).matches)
            return f[c];
      }
      return a;
    }
  };
  return Object.assign(s, o.match(i)), n.on("resize", window, M(function() {
    e.settings = I(s, o.match(i));
  }, e.settings.throttle)), r.on("update", function() {
    i = J(i), a = Object.assign({}, s);
  }), r.on("destroy", function() {
    n.off("resize", window);
  }), o;
}
var $t = {
  // Required
  Html: yt,
  Translate: Dt,
  Transition: zt,
  Direction: Ht,
  Peek: wt,
  Sizes: St,
  Gaps: mt,
  Move: _t,
  Clones: Tt,
  Resize: kt,
  Build: Ot,
  Run: pt,
  // Optional
  Swipe: It,
  Images: Et,
  Anchors: Vt,
  Controls: qt,
  Keyboard: Kt,
  Autoplay: Xt,
  Breakpoints: Yt
}, Ut = /* @__PURE__ */ function(e) {
  it(r, e);
  var t = ut(r);
  function r() {
    return B(this, r), t.apply(this, arguments);
  }
  return L(r, [{
    key: "mount",
    value: function() {
      var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return x(T(r.prototype), "mount", this).call(this, Object.assign({}, $t, s));
    }
  }]), r;
}(vt);
function Q(e) {
  let t = document.createElement("div");
  return t.innerHTML = e.trim(), t.firstChild;
}
function Jt(e, t) {
  let n = Object.assign({
    type: "carousel",
    startAt: 0,
    perView: 3,
    focusAt: "center",
    gap: 20,
    autoplay: 2e3,
    hoverpause: !0,
    keyboard: !0,
    animationDuration: 400,
    arrows: !0,
    bullets: !1
  }, t), s = new Ut(e, n), i = new Array();
  if (n.arrows) {
    i.push('<div class="glide__arrows" data-glide-el="controls">'), i.push('<button class="glide__arrow glide__arrow--left" data-glide-dir="<"><svg viewBox="0 0 24 24" style="fill: currentColor;"><path d="M13.939 4.939 6.879 12l7.06 7.061 2.122-2.122L11.121 12l4.94-4.939z"></path></svg></button>'), i.push('<button class="glide__arrow glide__arrow--right" data-glide-dir=">"><svg viewBox="0 0 24 24" style="fill: currentColor;"><path d="M10.061 19.061 17.121 12l-7.06-7.061-2.122 2.122L12.879 12l-4.94 4.939z"></path></svg></button>'), i.push("</div>");
    let a = Q(i.join(""));
    e.append(a);
  }
  if (n.bullets) {
    i = new Array(), i.push('<div class="glide__bullets" data-glide-el="controls[nav]">'), i.push('<button class="glide__bullet" data-glide-dir="=0"></button>'), i.push('<button class="glide__bullet" data-glide-dir="=1"></button>'), i.push('<button class="glide__bullet" data-glide-dir="=2"></button>'), i.push("</div>");
    let a = Q(i.join(""));
    e.append(a);
  }
  return s.mount(), s;
}
export {
  Jt as default
};
//# sourceMappingURL=index.es.min.js.map
